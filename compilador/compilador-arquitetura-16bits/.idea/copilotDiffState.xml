<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Compilador para Arquitetura de 16 bits&#10;&#10;## Descrição&#10;Este compilador traduz código assembly para uma arquitetura customizada de 16 bits com 8 registradores (R0-R7).&#10;&#10;## Conjunto de Instruções Suportadas&#10;&#10;### Grupo 1 - Aritmética e Manipulação de Dados&#10;- **LDA Rdest, valor_imediato** - Carrega um valor imediato no registrador destino&#10;- **SUM Rdest, Rf1, Rf2** - Soma Rf1 com Rf2 e armazena em Rdest&#10;- **SUB Rdest, Rf1, Rf2** - Subtrai Rf2 de Rf1 e armazena em Rdest&#10;- **MUL Rdest, Rf1, Rf2** - Multiplica Rf1 por Rf2 e armazena em Rdest&#10;&#10;### Grupo 2 - Controle de Fluxo&#10;- **JMP endereço** - Desvia incondicionalmente para o endereço indicado&#10;- **BEQ Rf1, Rf2, endereço** - Desvia se Rf1 for igual a Rf2&#10;- **BNE Rf1, Rf2, endereço** - Desvia se Rf1 for diferente de Rf2&#10;&#10;## Formato das Instruções (16 bits)&#10;&#10;### Instruções Aritméticas&#10;- **LDA**: OPCODE(4) + REG_DEST(3) + VALOR_IMEDIATO(9)&#10;- **SUM/SUB/MUL**: OPCODE(4) + REG_DEST(3) + REG1(3) + REG2(3) + UNUSED(3)&#10;&#10;### Instruções de Controle&#10;- **JMP**: OPCODE(4) + ENDERECO(12)&#10;- **BEQ/BNE**: OPCODE(4) + REG1(3) + REG2(3) + ENDERECO(6)&#10;&#10;## Códigos de Operação (OPCODE)&#10;- LDA: 0001&#10;- SUM: 0010&#10;- SUB: 0011&#10;- MUL: 0100&#10;- JMP: 1001&#10;- BEQ: 1010&#10;- BNE: 1011&#10;&#10;## Exemplos de Uso&#10;&#10;### Exemplo 1: Operações Básicas&#10;```assembly&#10;LDA R0, 10      ; Carrega 10 em R0&#10;LDA R1, 5       ; Carrega 5 em R1&#10;SUM R2, R0, R1  ; R2 = R0 + R1 (15)&#10;SUB R3, R0, R1  ; R3 = R0 - R1 (5)&#10;MUL R4, R0, R1  ; R4 = R0 * R1 (50)&#10;```&#10;&#10;### Exemplo 2: Uso de Labels e Saltos&#10;```assembly&#10;LDA R0, 10&#10;LDA R1, 10&#10;BEQ R0, R1, igual&#10;JMP fim&#10;&#10;igual:&#10;LDA R2, 1&#10;&#10;fim:&#10;LDA R3, 0&#10;```&#10;&#10;### Exemplo 3: Loop Simples&#10;```assembly&#10;LDA R0, 5       ; Contador&#10;LDA R1, 0       ; Acumulador&#10;&#10;loop:&#10;SUM R1, R1, R0  ; Soma o contador ao acumulador&#10;SUB R0, R0, 1   ; Decrementa contador&#10;BNE R0, R0, loop ; Se R0 != 0, volta ao loop&#10;```&#10;&#10;## Limitações&#10;- Valores imediatos: 0-511 (9 bits)&#10;- Endereços: 0-4095 (12 bits para JMP, 6 bits para BEQ/BNE)&#10;- Registradores: R0-R7&#10;- Comentários começam com ';'&#10;&#10;## Como Usar a Interface&#10;1. Digite o código assembly na área de texto superior&#10;2. Clique em &quot;Compilar&quot;&#10;3. O código binário aparecerá na área de saída&#10;4. Labels e seus endereços serão listados ao final&#10;&#10;## Tratamento de Erros&#10;O compilador detecta e reporta:&#10;- Instruções não reconhecidas&#10;- Sintaxe incorreta&#10;- Registradores inválidos&#10;- Valores fora do range&#10;- Labels duplicados&#10;- Endereços inválidos" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/unipampa/compiladorarquitetura16bits/Compiler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/unipampa/compiladorarquitetura16bits/Compiler.java" />
              <option name="updatedContent" value="package com.unipampa.compiladorarquitetura16bits;&#10;&#10;import java.util.*;&#10;import java.util.regex.Pattern;&#10;&#10;public class Compiler {&#10;    &#10;    // Mapa para armazenar labels e seus endereços&#10;    private Map&lt;String, Integer&gt; labels = new HashMap&lt;&gt;();&#10;    &#10;    // Lista para armazenar o código compilado&#10;    private List&lt;String&gt; compiledCode = new ArrayList&lt;&gt;();&#10;    &#10;    // Contador de endereços&#10;    private int currentAddress = 0;&#10;    &#10;    public String compile(String sourceCode) throws Exception {&#10;        if (sourceCode == null || sourceCode.trim().isEmpty()) {&#10;            throw new Exception(&quot;Código fonte vazio&quot;);&#10;        }&#10;        &#10;        // Reset do estado&#10;        labels.clear();&#10;        compiledCode.clear();&#10;        currentAddress = 0;&#10;        &#10;        String[] lines = sourceCode.split(&quot;\n&quot;);&#10;        &#10;        // Primeira passada: identificar labels&#10;        firstPass(lines);&#10;        &#10;        // Segunda passada: gerar código&#10;        secondPass(lines);&#10;        &#10;        return generateOutput();&#10;    }&#10;    &#10;    private void firstPass(String[] lines) throws Exception {&#10;        currentAddress = 0;&#10;        &#10;        for (String line : lines) {&#10;            line = line.trim();&#10;            &#10;            // Ignorar linhas vazias e comentários&#10;            if (line.isEmpty() || line.startsWith(&quot;;&quot;)) {&#10;                continue;&#10;            }&#10;            &#10;            // Verificar se é um label&#10;            if (line.endsWith(&quot;:&quot;)) {&#10;                String label = line.substring(0, line.length() - 1).trim();&#10;                if (labels.containsKey(label)) {&#10;                    throw new Exception(&quot;Label duplicado: &quot; + label);&#10;                }&#10;                labels.put(label, currentAddress);&#10;            } else {&#10;                // É uma instrução, incrementar endereço&#10;                currentAddress++;&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void secondPass(String[] lines) throws Exception {&#10;        currentAddress = 0;&#10;        &#10;        for (String line : lines) {&#10;            line = line.trim();&#10;            &#10;            // Ignorar linhas vazias e comentários&#10;            if (line.isEmpty() || line.startsWith(&quot;;&quot;)) {&#10;                continue;&#10;            }&#10;            &#10;            // Ignorar labels&#10;            if (line.endsWith(&quot;:&quot;)) {&#10;                continue;&#10;            }&#10;            &#10;            // Compilar instrução&#10;            String compiled = compileInstruction(line, currentAddress);&#10;            compiledCode.add(String.format(&quot;%04d: %s&quot;, currentAddress, compiled));&#10;            currentAddress++;&#10;        }&#10;    }&#10;    &#10;    private String compileInstruction(String instruction, int address) throws Exception {&#10;        String[] parts = instruction.split(&quot;\\s+&quot;);&#10;        String opcode = parts[0].toUpperCase();&#10;        &#10;        switch (opcode) {&#10;            case &quot;LDA&quot;:&#10;                return compileLDA(parts);&#10;            case &quot;SUM&quot;:&#10;                return compileSUM(parts);&#10;            case &quot;SUB&quot;:&#10;                return compileSUB(parts);&#10;            case &quot;MUL&quot;:&#10;                return compileMUL(parts);&#10;            case &quot;JMP&quot;:&#10;                return compileJMP(parts);&#10;            case &quot;BEQ&quot;:&#10;                return compileBEQ(parts);&#10;            case &quot;BNE&quot;:&#10;                return compileBNE(parts);&#10;            default:&#10;                throw new Exception(&quot;Instrução não reconhecida: &quot; + opcode);&#10;        }&#10;    }&#10;    &#10;    // Compilação das instruções do Grupo 1 - Aritmética&#10;    private String compileLDA(String[] parts) throws Exception {&#10;        if (parts.length != 3) {&#10;            throw new Exception(&quot;LDA: Sintaxe incorreta. Use: LDA Rdest, valor_imediato&quot;);&#10;        }&#10;        &#10;        int destReg = parseRegister(parts[1]);&#10;        int value = parseValue(parts[2]);&#10;        &#10;        // Formato: OPCODE(4) + REG_DEST(3) + VALOR(9)&#10;        return String.format(&quot;0001%03d%09d&quot;, destReg, value &amp; 0x1FF);&#10;    }&#10;    &#10;    private String compileSUM(String[] parts) throws Exception {&#10;        if (parts.length != 4) {&#10;            throw new Exception(&quot;SUM: Sintaxe incorreta. Use: SUM Rdest, Rf1, Rf2&quot;);&#10;        }&#10;        &#10;        int destReg = parseRegister(parts[1]);&#10;        int reg1 = parseRegister(parts[2]);&#10;        int reg2 = parseRegister(parts[3]);&#10;        &#10;        // Formato: OPCODE(4) + REG_DEST(3) + REG1(3) + REG2(3) + UNUSED(3)&#10;        return String.format(&quot;0010%03d%03d%03d000&quot;, destReg, reg1, reg2);&#10;    }&#10;    &#10;    private String compileSUB(String[] parts) throws Exception {&#10;        if (parts.length != 4) {&#10;            throw new Exception(&quot;SUB: Sintaxe incorreta. Use: SUB Rdest, Rf1, Rf2&quot;);&#10;        }&#10;        &#10;        int destReg = parseRegister(parts[1]);&#10;        int reg1 = parseRegister(parts[2]);&#10;        int reg2 = parseRegister(parts[3]);&#10;        &#10;        return String.format(&quot;0011%03d%03d%03d000&quot;, destReg, reg1, reg2);&#10;    }&#10;    &#10;    private String compileMUL(String[] parts) throws Exception {&#10;        if (parts.length != 4) {&#10;            throw new Exception(&quot;MUL: Sintaxe incorreta. Use: MUL Rdest, Rf1, Rf2&quot;);&#10;        }&#10;        &#10;        int destReg = parseRegister(parts[1]);&#10;        int reg1 = parseRegister(parts[2]);&#10;        int reg2 = parseRegister(parts[3]);&#10;        &#10;        return String.format(&quot;0100%03d%03d%03d000&quot;, destReg, reg1, reg2);&#10;    }&#10;    &#10;    // Compilação das instruções do Grupo 2 - Controle de Fluxo&#10;    private String compileJMP(String[] parts) throws Exception {&#10;        if (parts.length != 2) {&#10;            throw new Exception(&quot;JMP: Sintaxe incorreta. Use: JMP endereço&quot;);&#10;        }&#10;        &#10;        int address = parseAddress(parts[1]);&#10;        &#10;        // Formato: OPCODE(4) + ENDERECO(12)&#10;        return String.format(&quot;1001%012d&quot;, address);&#10;    }&#10;    &#10;    private String compileBEQ(String[] parts) throws Exception {&#10;        if (parts.length != 4) {&#10;            throw new Exception(&quot;BEQ: Sintaxe incorreta. Use: BEQ Rf1, Rf2, endereço&quot;);&#10;        }&#10;        &#10;        int reg1 = parseRegister(parts[1]);&#10;        int reg2 = parseRegister(parts[2]);&#10;        int address = parseAddress(parts[3]);&#10;        &#10;        // Formato: OPCODE(4) + REG1(3) + REG2(3) + ENDERECO(6)&#10;        return String.format(&quot;1010%03d%03d%06d&quot;, reg1, reg2, address);&#10;    }&#10;    &#10;    private String compileBNE(String[] parts) throws Exception {&#10;        if (parts.length != 4) {&#10;            throw new Exception(&quot;BNE: Sintaxe incorreta. Use: BNE Rf1, Rf2, endereço&quot;);&#10;        }&#10;        &#10;        int reg1 = parseRegister(parts[1]);&#10;        int reg2 = parseRegister(parts[2]);&#10;        int address = parseAddress(parts[3]);&#10;        &#10;        return String.format(&quot;1011%03d%03d%06d&quot;, reg1, reg2, address);&#10;    }&#10;    &#10;    // Métodos auxiliares&#10;    private int parseRegister(String reg) throws Exception {&#10;        reg = reg.replace(&quot;,&quot;, &quot;&quot;).trim();&#10;        &#10;        if (!reg.matches(&quot;[Rr][0-7]&quot;)) {&#10;            throw new Exception(&quot;Registrador inválido: &quot; + reg + &quot;. Use R0-R7&quot;);&#10;        }&#10;        &#10;        return Integer.parseInt(reg.substring(1));&#10;    }&#10;    &#10;    private int parseValue(String value) throws Exception {&#10;        value = value.replace(&quot;,&quot;, &quot;&quot;).trim();&#10;        &#10;        try {&#10;            int val = Integer.parseInt(value);&#10;            if (val &lt; 0 || val &gt; 511) { // 9 bits = 0-511&#10;                throw new Exception(&quot;Valor fora do range (0-511): &quot; + val);&#10;            }&#10;            return val;&#10;        } catch (NumberFormatException e) {&#10;            throw new Exception(&quot;Valor inválido: &quot; + value);&#10;        }&#10;    }&#10;    &#10;    private int parseAddress(String address) throws Exception {&#10;        address = address.replace(&quot;,&quot;, &quot;&quot;).trim();&#10;        &#10;        // Verificar se é um label&#10;        if (labels.containsKey(address)) {&#10;            return labels.get(address);&#10;        }&#10;        &#10;        // Senão, tentar como número&#10;        try {&#10;            int addr = Integer.parseInt(address);&#10;            if (addr &lt; 0 || addr &gt; 4095) { // 12 bits = 0-4095&#10;                throw new Exception(&quot;Endereço fora do range (0-4095): &quot; + addr);&#10;            }&#10;            return addr;&#10;        } catch (NumberFormatException e) {&#10;            throw new Exception(&quot;Endereço ou label inválido: &quot; + address);&#10;        }&#10;    }&#10;    &#10;    private String generateOutput() {&#10;        StringBuilder output = new StringBuilder();&#10;        output.append(&quot;=== CÓDIGO COMPILADO ===\n&quot;);&#10;        output.append(&quot;Formato: Endereço: Código Binário (16 bits)\n\n&quot;);&#10;        &#10;        for (String line : compiledCode) {&#10;            output.append(line).append(&quot;\n&quot;);&#10;        }&#10;        &#10;        output.append(&quot;\n=== LABELS ENCONTRADOS ===\n&quot;);&#10;        for (Map.Entry&lt;String, Integer&gt; entry : labels.entrySet()) {&#10;            output.append(String.format(&quot;%s: %04d\n&quot;, entry.getKey(), entry.getValue()));&#10;        }&#10;        &#10;        return output.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>